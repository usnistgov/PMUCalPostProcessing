classdef PmuCalReport < handle
    
    properties
        % PMU configuration
        PmuClass = 'M' % PMU Class Configuration
        vNom = 70   % PMU nominal voltage configuration
        iNom = 5    % PMU nominal current configuration
        Fs = 50     % PMU Reporting Rate Configuration
        F0 = 50     % PMU Nominal Frequency configuration
        ResultType
        
        % 
        hExcel      % handle to the Excel activeX object
        resultPath  % Path to the result files generated by the PMU calibrator
        paramFiles  % 
        dataFiles   %
        ReportFile  % Report file to be created   
        
        % figure default sizes
        figPos = [1664 1848 360 250];   % figure position
        axPos = [0.1 0.15 0.6 0.75];     % axis position
        lgdPos = [0.71 0.425 0.27 0.2475]; % legend position
        
        specifications %specifications read from .xml file for the current PMU configuration

        
        
    end
    %%  ----------------------------------------------------------------------------------------------------------------------------------
    % Constructor
    methods
        
        function self = PmuCalReport(varargin)
            % Constructor for PmuCalReport Class
            % obj = PmuCalReport(<option list>)
            %       options: Name-Value Pair Arguments (in any order)
            %           "vNom" - PMU nominal voltage (default = 70)
            %           "iNom" - PMU nominal current (default = 5)
            %           "Fs" - PMU reporting rate (default = 50)
            %           "F0" - PMU nominal frequency (default = 50)
            %           "PmuClass - PMU class (default = M)
            %           "Reset" - (t,T,true,True) - resets the  appdata allowing the user to choose new results and report file paths
            
            appDataPath = fullfile(getenv('APPDATA'),'PmuCal');
            if ~exist(appDataPath, 'dir' )
                mkdir(appDataPath)
            end
            name = 'PmuCalReport.ini';
            
            % input arguments
            for i = 1:2:nargin
                switch varargin{i}
                    case 'vNom'
                        self.vNom = varargin{i+1};
                    case 'iNom'
                        self.iNom = varargin{i+1};
                    case 'Fs'
                        self.Fs = varargin{i+1};
                    case 'F0'
                        self.F0 = varargin{i+1};
                    case 'PmuClass'
                        self.PmuClass = varargin{i+1};
                    case 'Reset'    % delete the .ini file
                        b = varargin{i+1};
                        if b=="t" || b=="T"|| b=="true" || b=="True"
                            if exist(fullfile(appDataPath,name),'file')
                                delete(fullfile(appDataPath,name))
                            end
                        end
                    otherwise
                        warning('Unrecognized parameter %s',varargin{i});
                end
                
            end
            
            
            % program .ini file
            if ~exist(fullfile(appDataPath,name),'file')
                self.resultPath = uigetdir(fullfile(getenv('USERPROFILE'),'Documents'),'Path to PMU results');
                structure = struct('ResultsPath',struct('ResultsPath',self.resultPath));
                self.struct2Ini(fullfile(appDataPath,name),structure);
            else
                structure = self.ini2struct(fullfile(appDataPath,name));
                self.resultPath = structure.ResultsPath.ResultsPath;
            end
                                       
        end
    end
    
%%  ----------------------------------------------------------------------------------------------------------------------------------
    % Public Methods called from external method files
    methods (Access = public)
        self = getResultsFileList(self)
        self = makeReportFileName(self)
        self = makeNewReportFile(self)
        self = writeAnalysisToExcel(self)
        plotExcelAnalysis(self)

    end
    
%%  ----------------------------------------------------------------------------------------------------------------------------------
    % Private Methods called from external method files
    methods (Access = private)
        [sheetName, influenceFactor] = NistParams(self,T)
        [sheetName, influenceFactor] = FlukeParams(self,T)
        [i] = writeStepResultsToExcel(self,i,influenceFactor)
        [nextLine] = writeResultsToExcel(self,nextLine,i,new,influenceFactor)
        plotResults(self,T,Lim,xLabel)
        plotStepResults(self,T,Lim,xLabel)
    end
    
    
%%  ----------------------------------------------------------------------------------------------------------------------------------
% Local Private Methods
methods (Access = private)
    % Recursively collect all files from subfolders
    function filenames = getfn(self,folder,pattern)
        getfnrec(folder,pattern)
        
        idx = ~cellfun(@isempty, regexp(filenames,pattern));
        filenames =filenames(idx);
        
        % This nested function recursively goes through all subfolders
        % and collects all filenames within them
        function getfnrec(path,pattern)
            d = dir(path);
            filenames = {d(~[d.isdir]).name};
            filenames = strcat(path,filesep,filenames);
            
            dirnames = {d([d.isdir]).name};
            dirnames = setdiff(dirnames,{'.','..'});
            for i = 1:numel(dirnames)
                fulldirname = [path filesep dirnames{i}];
                filenames = [filenames, self.getfn(fulldirname,pattern)];
            end
        end
    end
    
    %-----------------------    
    function [sheetName, influenceFactor] = makeSheetName(self,paramsFile)
        % from a parameter file, return the name of the excel sheet to write
        C = readcell(cell2mat(paramsFile));    % read params file to a cell array
        C = C';
        T = cell2table(C(2:end,:));     % cell array to a table
        
        % a problem with some of the paramfiles: duplicate parameter
        % names
        A = C(1,:);
        [~,~,X] = unique(A(:),'stable');
        Y = hist(X,unique(X));
        Y = (Y~=1);
        idx = find(Y==1);
        for i = 1:numel(idx)
            dupIdx = find(X==idx(i));
            for ii = 1:numel(dupIdx)
                A{dupIdx(ii)} = sprintf('%s%d',A{dupIdx(ii)},ii);
            end
        end
        T.Properties.VariableNames = A;
        if size(T,1)>2
            [sheetName, influenceFactor] = self.NistParams(T);
        else
            [sheetName, influenceFactor] = self.FlukeParams(T);
        end
    end
    
    % --------------------------
    % Either create a new sheet or set the sheet active
    function [new] = activeSheet(self,sheetName)
        % first, find out if a sheet exists
        new = false;
        [nbSheets,shList] = self.hExcel.ListSheets;
        
        % if there is only one sheet, and it's name is "Sheet1", rename
        % the sheet.
        if nbSheets == 1
            if shList{2} == "Sheet1"
                self.hExcel.GetSheet('Sheet1');
                self.hExcel.NameSheet(sheetName);
                new = true;
                return;
            end
        end
        
        % Check to see if the sheet already exist
        if numel(find(strcmp(shList(:,2),sheetName))) == 0
            self.hExcel.GetSheet(shList{end,2});
            self.hExcel.NewSheet(sheetName);    % make one if it does not exist
            new = true;
        end
        self.hExcel.GetSheet(sheetName)  % get the sheet
    end   
    
    function writeExcelHeader(self,Hdr)
        nLine = numel(Hdr); % length of the header line
        nLine = self.hExcel.num2letters(nLine);
        rng = strcat('A1:',nLine,'1');
        self.hExcel.AddRange('Hdr','Cells',rng{1});
        self.hExcel.WriteRange('Hdr',Hdr(1,:));
    end
    
    function Lim = getLimitsFromSheetName(self,sheetname)
        % from the sheet name, get the TVE, FE and RFE limits from the
        % specifications property
        switch sheetname
            case 'frequency range'
                Lim = self.specifications.FreqRng;
                return
                
            case 'signal magnitude'
                Lim = self.specifications.MagRng;
                return
                
            case 'harmonic distortion'
                Lim = self.specifications.Harm;
                return
                
            case 'out of band interference'
                Lim = self.specifications.OOB;
                return
                
            case 'frequency ramp'
                Lim = self.specifications.RampPos;
                return
                
            case {'phase modulation', 'amplitude modulation', 'combined modulation'}
                Lim = self.specifications.AmplMod;
                return
                
            case {'phase step pos' 'phase step neg', 'combined step'}
                Lim = [self.specifications.PhaseStepRespTime; self.specifications.PhaseStepDelayTime; self.specifications.PhaseStepOvershoot];
                return
                
            case {'amplitude step pos' 'amplitude step neg'}
                Lim = [self.specifications.MagStepResponseTime; self.specifications.MagStepDelayTime; self.specifications.MagStepOvershoot];
                return
                
                
            otherwise
                warning ('There are no known limits for %s', sheetname)
        end
        
    end
    
end
     

    %%  ----------------------------------------------------------------------------------------------------------------------------------
    % Local Static Methods
    methods(Static)
        
        % write a structure to a .ini file
        % Dirk Lohse (2021). struct2ini (
        % https://www.mathworks.com/matlabcentral/fileexchange/22079-struct2ini), 
        % MATLAB Central File Exchange. Retrieved January 15, 2021.
        function struct2Ini(file,structure)
            fid = fopen(file,'w');
            
            sects = fieldnames(structure);
            
            for i = 1:numel(sects)
                sect = char(sects(i));
                fprintf(fid,'\n[%s]\n',sect);
                mem = structure.(sect);
                if ~isempty(mem)
                    memNames = fieldnames(mem);
                    for j = 1:numel(memNames)
                        memName = char(memNames(j));
                        memVal = structure.(sect).(memName);
                        fprintf(fid,'%s=%s\n',memName,memVal);
                    end                    
                end
            end
            fclose(fid);
        end
        
        % read a structure from a .ini file
        %freeb (2021). ini2struct
        %(https://www.mathworks.com/matlabcentral/fileexchange/45725-ini2struct),
        %MATLAB Central File Exchange. Retrieved January 15, 2021.
        function Struct = ini2struct(FileName)
            % Parses .ini file
            % Returns a structure with section names and keys as fields.
            %
            % Based on init2struct.m by Andriy Nych
            % 2014/02/01
            f = fopen(FileName,'r');                    % open file
            while ~feof(f)                              % and read until it ends
                s = strtrim(fgetl(f));                  % remove leading/trailing spaces
                if isempty(s) || s(1)==';' || s(1)=='#' % skip empty & comments lines
                    continue
                end
                if s(1)=='['                            % section header
                    Section = genvarname(strtok(s(2:end), ']'));
                    Struct.(Section) = [];              % create field
                    continue
                end
                
                [Key,Val] = strtok(s, '=');             % Key = Value ; comment
                Val = strtrim(Val(2:end));              % remove spaces after =
                
                if isempty(Val) || Val(1)==';' || Val(1)=='#' % empty entry
                    Val = [];
                elseif Val(1)=='"'                      % double-quoted string
                    Val = strtok(Val, '"');
                elseif Val(1)==''''                     % single-quoted string
                    Val = strtok(Val, '''');
                else
                    Val = strtok(Val, ';');             % remove inline comment
                    Val = strtok(Val, '#');             % remove inline comment
                    Val = strtrim(Val);                 % remove spaces before comment
                    
                    [val, status] = str2num(Val);       
                    if status, Val = val; end           % convert string to number(s)
                end
                
                if ~exist('Section', 'var')             % No section found before
                    Struct.(genvarname(Key)) = Val;
                else                                    % Section found before, fill it
                    Struct.(Section).(genvarname(Key)) = Val;
                end
            end
            fclose(f);                        
        end
        
        
    end
    
end
    